{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "d23f1b2a-3b3f-4f73-ade0-e760e386ecf3",
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "0it [00:00, ?it/s]\n",
      "2025-10-19 15:59:31.390 \n",
      "  \u001b[33m\u001b[1mWarning:\u001b[0m to view this Streamlit app on a browser, run it with the following\n",
      "  command:\n",
      "\n",
      "    streamlit run C:\\Users\\gregr\\anaconda3\\Lib\\site-packages\\ipykernel_launcher.py [ARGUMENTS]\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "DeltaGenerator()"
      ]
     },
     "execution_count": 1,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# ===========================\n",
    "# Sustainable Flight Advisor MVP\n",
    "# ===========================\n",
    "\n",
    "# --- 1) Imports ---\n",
    "import pandas as pd\n",
    "import math\n",
    "from sklearn.ensemble import RandomForestClassifier\n",
    "from sklearn.model_selection import train_test_split\n",
    "from sklearn.metrics import roc_auc_score\n",
    "import streamlit as st\n",
    "from tqdm import tqdm  # optional for progress bars\n",
    "\n",
    "# ===========================\n",
    "# 2) Load Airports & Routes\n",
    "# ===========================\n",
    "# Airports (OpenFlights)\n",
    "airports_url = \"https://raw.githubusercontent.com/jpatokal/openflights/master/data/airports.dat\"\n",
    "airports = pd.read_csv(\n",
    "    airports_url,\n",
    "    header=None,\n",
    "    names=[\"id\",\"name\",\"city\",\"country\",\"iata\",\"icao\",\"lat\",\"lon\",\"alt\",\"tz\",\"dst\",\"tzdb\"],\n",
    "    quotechar='\"'\n",
    ")\n",
    "airports['iata'] = airports['iata'].astype(str).str.strip().str.upper()\n",
    "airports = airports[airports['iata'].str.len() == 3]  # keep only real 3-letter IATA codes\n",
    "\n",
    "# Routes (OpenFlights)\n",
    "routes_url = \"https://raw.githubusercontent.com/jpatokal/openflights/master/data/routes.dat\"\n",
    "routes = pd.read_csv(\n",
    "    routes_url,\n",
    "    header=None,\n",
    "    names=[\"airline\",\"airline_id\",\"source_airport\",\"source_airport_id\",\n",
    "           \"dest_airport\",\"dest_airport_id\",\"codeshare\",\"stops\",\"equipment\"],\n",
    "    quotechar='\"'\n",
    ")\n",
    "\n",
    "# Merge coordinates\n",
    "routes = routes.merge(\n",
    "    airports[['iata','lat','lon']],\n",
    "    left_on='source_airport',\n",
    "    right_on='iata',\n",
    "    how='left'\n",
    ").rename(columns={'lat':'source_lat','lon':'source_lon'}).drop(columns='iata')\n",
    "\n",
    "routes = routes.merge(\n",
    "    airports[['iata','lat','lon']],\n",
    "    left_on='dest_airport',\n",
    "    right_on='iata',\n",
    "    how='left'\n",
    ").rename(columns={'lat':'dest_lat','lon':'dest_lon'}).drop(columns='iata')\n",
    "\n",
    "# Drop routes with missing coordinates\n",
    "routes = routes.dropna(subset=['source_lat','source_lon','dest_lat','dest_lon']).reset_index(drop=True)\n",
    "\n",
    "# ===========================\n",
    "# 3) Distance & CO2 Calculator\n",
    "# ===========================\n",
    "def haversine_km(lat1, lon1, lat2, lon2):\n",
    "    R = 6371.0\n",
    "    phi1 = math.radians(lat1); phi2 = math.radians(lat2)\n",
    "    dphi = math.radians(lat2 - lat1); dlambda = math.radians(lon2 - lon1)\n",
    "    a = math.sin(dphi/2)**2 + math.cos(phi1)*math.cos(phi2)*math.sin(dlambda/2)**2\n",
    "    return R * 2 * math.asin(math.sqrt(a))\n",
    "\n",
    "DEFAULT_FACTOR_G_PER_PKM = 83.0  # g CO2 per pax-km\n",
    "\n",
    "distances = []\n",
    "co2s = []\n",
    "\n",
    "for _, row in tqdm(routes.iterrows(), total=len(routes)):\n",
    "    d = haversine_km(row['source_lat'], row['source_lon'], row['dest_lat'], row['dest_lon'])\n",
    "    distances.append(d)\n",
    "    co2s.append(d * DEFAULT_FACTOR_G_PER_PKM / 1000.0)  # kg CO2\n",
    "\n",
    "routes['distance_km'] = distances\n",
    "routes['co2_kg'] = co2s\n",
    "\n",
    "# ===========================\n",
    "# 4) BTS On-Time Delay Model (AI)\n",
    "# ===========================\n",
    "# Placeholder: replace with actual BTS data\n",
    "# Expected columns: origin, dest, carrier, dep_hour, day_of_week, month, label_delay (>15min)\n",
    "# bts_df = pd.read_csv(\"BTS_OnTimeData.csv\")\n",
    "\n",
    "# For MVP demo, create a dummy dataset\n",
    "# Normally you would load thousands/millions of BTS rows here\n",
    "bts_df = pd.DataFrame({\n",
    "    'origin':['JFK','LAX','SFO','JFK'],\n",
    "    'dest':['SFO','JFK','LAX','SFO'],\n",
    "    'carrier':['AA','AA','UA','DL'],\n",
    "    'dep_hour':[8,12,15,9],\n",
    "    'day_of_week':[1,2,3,4],\n",
    "    'month':[1,2,3,4],\n",
    "    'delayed':[0,1,0,1]  # label\n",
    "})\n",
    "\n",
    "features = ['dep_hour','day_of_week','month']  # extend with origin/dest/carrier encoding\n",
    "X = bts_df[features]\n",
    "y = bts_df['delayed']\n",
    "\n",
    "model = RandomForestClassifier(n_estimators=50, random_state=42)\n",
    "model.fit(X, y)\n",
    "\n",
    "# Example: predict delay probability for a route\n",
    "bts_df['delay_prob'] = model.predict_proba(X)[:,1]\n",
    "\n",
    "# ===========================\n",
    "# 5) Combine with Routes\n",
    "# ===========================\n",
    "# For simplicity, merge on origin/dest/carrier for MVP\n",
    "routes_demo = routes.merge(\n",
    "    bts_df[['origin','dest','carrier','delay_prob']],\n",
    "    left_on=['source_airport','dest_airport','airline'],\n",
    "    right_on=['origin','dest','carrier'],\n",
    "    how='left'\n",
    ")\n",
    "\n",
    "# Fill NaN delay probabilities with average or 0.1 for demo\n",
    "routes_demo['delay_prob'] = routes_demo['delay_prob'].fillna(0.1)\n",
    "\n",
    "# ===========================\n",
    "# 6) Streamlit UI\n",
    "# ===========================\n",
    "st.title(\"Sustainable Flight Advisor MVP\")\n",
    "\n",
    "origin_input = st.text_input(\"Origin IATA:\", value=\"JFK\").upper()\n",
    "dest_input = st.text_input(\"Destination IATA:\", value=\"SFO\").upper()\n",
    "\n",
    "filtered = routes_demo[\n",
    "    (routes_demo['source_airport']==origin_input) &\n",
    "    (routes_demo['dest_airport']==dest_input)\n",
    "]\n",
    "\n",
    "# Rank by CO2 + delay probability\n",
    "filtered['score'] = filtered['co2_kg'] * 0.5 + filtered['delay_prob'] * 100  # simple weighted score\n",
    "filtered = filtered.sort_values('score')\n",
    "\n",
    "st.write(f\"Available routes from {origin_input} to {dest_input}:\")\n",
    "st.dataframe(filtered[['airline','source_airport','dest_airport','distance_km','co2_kg','delay_prob','score']])\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.7"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
